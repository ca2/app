// Refactoring based on ca2 sequence theoric classes by
//     camilo on 2024-1007 17:56 <3ThomasBorregaardSorensen!!
#pragma once

//
////#include "acme/prototype/prototype/payload.h"
//class sequence;
//
////template < typename SEQUENCE >
//class step :
//   virtual public ::subparticle
//{
//public:
//
//
//   ::pointer< sequence >      m_psequence;
//   //::payload                              m_payloadResult;
//   //::pointer < ::subparticle >                                                 m_pstepNext;
//
//   //virtual void run()
//   //{
//
//   //   aggregate(m_psequence);
//
//   //}
//
//   //virtual void aggregate(::sequence * psequence)
//   //{
//   //   
//   //}
//
//
//   //virtual void do_asynchronously()
//   //{
//
//
//   //}
//
//
//   //inline SEQUENCE * get() { return this; }
//   //inline const SEQUENCE * get() const { return this; }
//
//   //sequence * then(const sequence_step < SEQUENCE > & function);
//
//   //sequence * then(const class time & time, const sequence_step < SEQUENCE > & function);
//
//
//
//};


//template < typename OBJECT, typename TRANSPORT , typename SEQUENCE >
//SEQUENCE * asynchronous < OBJECT, TRANSPORT, SEQUENCE >::sequence()
//{
//
//   if (!m_pfuture)
//   {
//
//      system()->øconstruct_new(m_pfuture);
//       
//      m_pfuture->system() = system();
//
//      m_pfuture->m_p = this;
//
//   }
//
//   return m_pfuture;
//
//}




//template < typename TYPE >
//inline ::pointer<TYPE>property_object::øcreate_new()
//{
//
//   auto p = øallocate TYPE();
//
//   p->initialize_matter(this);
//
//   return p;
//
//}


//#endif // __cplusplus_winrt
