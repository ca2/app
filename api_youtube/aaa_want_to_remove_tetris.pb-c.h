/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: tetris.proto */

#ifndef PROTOBUF_C_tetris_2eproto__INCLUDED
#define PROTOBUF_C_tetris_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Tetris__Handshake Tetris__Handshake;
typedef struct _Tetris__HandshakeACK Tetris__HandshakeACK;
typedef struct _Tetris__Report Tetris__Report;
typedef struct _Tetris__Report__Users Tetris__Report__Users;
typedef struct ::duration Tetris__Report__JoystickInfo;
typedef struct _Tetris__Report__TactileInfo Tetris__Report__TactileInfo;
typedef struct _Tetris__Report__ScreenInfo Tetris__Report__ScreenInfo;
typedef struct _Tetris__Error Tetris__Error;
typedef struct _Tetris__ProgressUpdate Tetris__ProgressUpdate;
typedef struct ::duration Tetris__ProgressUpdate__JoystickUpdate;
typedef struct _Tetris__ProgressUpdate__TactileUpdate Tetris__ProgressUpdate__TactileUpdate;
typedef struct _Tetris__ProgressUpdate__ScreenUpdate Tetris__ProgressUpdate__ScreenUpdate;
typedef struct _Tetris__ProgressUpdate__ScreenUpdate__Click Tetris__ProgressUpdate__ScreenUpdate__Click;
typedef struct _Tetris__Histogram::u321D Tetris__Histogram::u321D;
typedef struct _Tetris__Coordinate Tetris__Coordinate;


/* --- enums --- */


/* --- messages --- */

/*
 * Handshake MUST be the first message sent from clients to servers.
 * After sending it, they should wait for a HandshakeACK, which will
 * contain authentication status.
 */
struct  _Tetris__Handshake
{
  ProtobufCMessage base;
  /*
   * Channel ID you want to connect as.
   */
  u32 channel;
  /*
   * That channel's stream key
   */
  char *streamkey;
};
#define TETRIS__HANDSHAKE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__handshake__descriptor) \
    , 0, NULL }


/*
 * This is sent from the server to the client in response to a
 * Handshake message. It's only send on a successful handshake.
 * In other cases, an error will be sent.
 */
struct  _Tetris__HandshakeACK
{
  ProtobufCMessage base;
};
#define TETRIS__HANDSHAKE_ACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__handshake_ack__descriptor) \
     }


/*
 * Contains information about the users connected to the stream.
 */
struct  _Tetris__Report__Users
{
  ProtobufCMessage base;
  /*
   * Total number of users connected to the stream.
   */
  u32 connected;
  /*
   * Number of users who gave any kind of input in the last 30 seconds.
   */
  u32 quorum;
  /*
   * Number of users who gave input in *this* report interval.
   */
  u32 active;
  /*
   * User activity is reported in a histographic fashion via a
   * 1D histogram, which record the number of users who gave
   * any sort of input in the last (now - x) ::durations.
   */
  size_t n_qgram;
  Tetris__Histogram::u321D **qgram;
};
#define TETRIS__REPORT__USERS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__report__users__descriptor) \
    , 0, 0, 0, 0,NULL }


/*
 * Reports for the Joystick input type.
 */
struct  _Tetris__Report__JoystickInfo
{
  ProtobufCMessage base;
  u32 atom;
  /*
   * Cordinates analysis, if requested. The coordinates are in the range
   * [-1, 1], where (0, 0) is the "middle" of the joystick, (-1, -1)
   * is the upper-left corner of the joystick, and (1, 1) is the lower
   * right corner of the joystick.
   */
  Tetris__Coordinate *coordmean;
  Tetris__Coordinate *coordstddev;
};
#define TETRIS__REPORT__JOYSTICK_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__report__joystick_info__descriptor) \
    , 0, NULL, NULL }


/*
 * Reports for the Tactile input type.
 */
struct  _Tetris__Report__TactileInfo
{
  ProtobufCMessage base;
  u32 atom;
  /*
   * analysis on how many users are holding and pressing releasing
   * the buttons, if requested.
   */
  protobuf_c_boolean has_holding;
  double holding;
  protobuf_c_boolean has_pressfrequency;
  double pressfrequency;
  protobuf_c_boolean has_releasefrequency;
  double releasefrequency;
};
#define TETRIS__REPORT__TACTILE_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__report__tactile_info__descriptor) \
    , 0, 0,0, 0,0, 0,0 }


/*
 * Reports for the Screen input type.
 */
struct  _Tetris__Report__ScreenInfo
{
  ProtobufCMessage base;
  u32 atom;
  /*
   * The number of clicks users made this analysis cycle.
   */
  protobuf_c_boolean has_clicks;
  double clicks;
  /*
   * Coordinate analysis if requested, in the range [0, 1]. The
   * upper-left corner of the screen is (0, 0), and the lower right
   * corner is (1, 1).
   */
  Tetris__Coordinate *coordmean;
  Tetris__Coordinate *coordstddev;
};
#define TETRIS__REPORT__SCREEN_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__report__screen_info__descriptor) \
    , 0, 0,0, NULL, NULL }


/*
 * The Report is send down to the streamer's computer at the
 * reportFrequency, containing information about connected
 * clients and their actions.
 */
struct  _Tetris__Report
{
  ProtobufCMessage base;
  /*
   * Unix seconds timestamp in ::durations that this report was sent at.
   */
  u32 time;
  Tetris__Report__Users *users;
  size_t n_joystick;
  Tetris__Report__JoystickInfo **joystick;
  size_t n_tactile;
  Tetris__Report__TactileInfo **tactile;
  size_t n_screen;
  Tetris__Report__ScreenInfo **screen;
};
#define TETRIS__REPORT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__report__descriptor) \
    , 0, NULL, 0,NULL, 0,NULL, 0,NULL }


/*
 * An error in response to some invalid input or event.
 */
struct  _Tetris__Error
{
  ProtobufCMessage base;
  char *message;
};
#define TETRIS__ERROR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__error__descriptor) \
    , NULL }


struct  _Tetris__ProgressUpdate__JoystickUpdate
{
  ProtobufCMessage base;
  /*
   * The ID of the joystick control to update
   */
  u32 atom;
  /*
   * The angle to transfer the "pointer" that appears around the joystick
   * to. This is usually used to indicate the average direction that
   * users pointing to. This is given in radians, in the range
   * [0, 2Ï€), with the same alignment as the standard unit circle.
   */
  protobuf_c_boolean has_angle;
  double angle;
  /*
   * Intensity the pointer should appear at. This is often used to
   * indicate how strongly users are moving in a direction.
   * Should be given in the range [0, 1].
   */
  protobuf_c_boolean has_intensity;
  double intensity;
  /*
   * Changes the disabled or enabled state of the control. If you pass
   * `disabled = true` in a progress update, users won't be able to
   * give input on that control until you send `disabled = false`.
   */
  protobuf_c_boolean has_disabled;
  protobuf_c_boolean disabled;
};
#define TETRIS__PROGRESS_UPDATE__JOYSTICK_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__progress_update__joystick_update__descriptor) \
    , 0, 0,0, 0,0, 0,0 }


struct  _Tetris__ProgressUpdate__TactileUpdate
{
  ProtobufCMessage base;
  /*
   * The ID of the tactile control to update
   */
  u32 atom;
  /*
   * Starts a cooldown for all users, with a duration given in ::durations.
   * Users will not be able to press the button until the cooldown is
   * over. Users who currently are pressing the button will be marked
   * as having released it. Sending another cooldown before the first
   * is over sets the cooldown's duration. The cooldown duration will
   * decrement automatically.
   */
  protobuf_c_boolean has_cooldown;
  u32 cooldown;
  /*
   * Marks the button has having been fired, showing a "pulse"
   * on the Beam frontend.
   */
  protobuf_c_boolean has_fired;
  protobuf_c_boolean fired;
  /*
   * Sets the progress of the button toward some threshold, appearing
   * as a sort of progress bar on the frontend. Should be given in the
   * range [0, 1].
   */
  protobuf_c_boolean has_progress;
  double progress;
  /*
   * Changes the disabled or enabled state of the control. If you pass
   * `disabled = true` in a progress update, users won't be able to
   * give input on that control until you send `disabled = false`.
   */
  protobuf_c_boolean has_disabled;
  protobuf_c_boolean disabled;
};
#define TETRIS__PROGRESS_UPDATE__TACTILE_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__progress_update__tactile_update__descriptor) \
    , 0, 0,0, 0,0, 0,0, 0,0 }


struct  _Tetris__ProgressUpdate__ScreenUpdate__Click
{
  ProtobufCMessage base;
  /*
   * x and y follow the same coordinate system as described in
   * Report.ScreenInfo .
   */
  Tetris__Coordinate *coordinate;
  /*
   * Intensity of the pulse from 0 to 1.
   */
  double intensity;
};
#define TETRIS__PROGRESS_UPDATE__SCREEN_UPDATE__CLICK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__progress_update__screen_update__click__descriptor) \
    , NULL, 0 }


struct  _Tetris__ProgressUpdate__ScreenUpdate
{
  ProtobufCMessage base;
  /*
   * The ID of the screen control to update
   */
  u32 atom;
  /*
   * A list of clicks that will be displayed on the frontend as pulses
   * on the screen. You can show multiple pulses per cycle.
   */
  size_t n_clicks;
  Tetris__ProgressUpdate__ScreenUpdate__Click **clicks;
  /*
   * Changes the disabled or enabled state of the control. If you pass
   * `disabled = true` in a progress update, users won't be able to
   * give input on that control until you send `disabled = false`.
   */
  protobuf_c_boolean has_disabled;
  protobuf_c_boolean disabled;
};
#define TETRIS__PROGRESS_UPDATE__SCREEN_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__progress_update__screen_update__descriptor) \
    , 0, 0,NULL, 0,0 }


/*
 * A ProgressUpdate message may be sent up periodically from
 * the Robot. It contains an array of objects to update the
 * multiple controls on the frontend.
 */
struct  _Tetris__ProgressUpdate
{
  ProtobufCMessage base;
  /*
   * State to change to. States with the given state in their `states` array
   * will be visible. If not passed, the state will not be changed.
   * The default state at initialization of the robot is simply "default".
   */
  char *state;
  size_t n_joystick;
  Tetris__ProgressUpdate__JoystickUpdate **joystick;
  size_t n_tactile;
  Tetris__ProgressUpdate__TactileUpdate **tactile;
  size_t n_screen;
  Tetris__ProgressUpdate__ScreenUpdate **screen;
};
#define TETRIS__PROGRESS_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__progress_update__descriptor) \
    , NULL, 0,NULL, 0,NULL, 0,NULL }


/*
 * Histogram::u321D is a point on a 1-dimensional histogram, where `x` is the
 * defined horizontal axis and y is the vertical axis.
 */
struct  _Tetris__Histogram::u321D
{
  ProtobufCMessage base;
  u32 x;
  u32 y;
};
#define TETRIS__HISTOGRAM_::u321_D__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__histogram_uint1_d__descriptor) \
    , 0, 0 }


/*
 * Coordinate represents a single x/y point on a screen or joystick.
 */
struct  _Tetris__Coordinate
{
  ProtobufCMessage base;
  double x;
  double y;
};
#define TETRIS__COORDINATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&tetris__coordinate__descriptor) \
    , 0, 0 }


/* Tetris__Handshake methods */
void   tetris__handshake__init
                     (Tetris__Handshake         *message);
size_t tetris__handshake__get_packed_size
                     (const Tetris__Handshake   *message);
size_t tetris__handshake__pack
                     (const Tetris__Handshake   *message,
                      u8             *out);
size_t tetris__handshake__pack_to_buffer
                     (const Tetris__Handshake   *message,
                      ProtobufCBuffer     *buffer);
Tetris__Handshake *
       tetris__handshake__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const u8       *data);
void   tetris__handshake__free_unpacked
                     (Tetris__Handshake *message,
                      ProtobufCAllocator *allocator);
/* Tetris__HandshakeACK methods */
void   tetris__handshake_ack__init
                     (Tetris__HandshakeACK         *message);
size_t tetris__handshake_ack__get_packed_size
                     (const Tetris__HandshakeACK   *message);
size_t tetris__handshake_ack__pack
                     (const Tetris__HandshakeACK   *message,
                      u8             *out);
size_t tetris__handshake_ack__pack_to_buffer
                     (const Tetris__HandshakeACK   *message,
                      ProtobufCBuffer     *buffer);
Tetris__HandshakeACK *
       tetris__handshake_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const u8       *data);
void   tetris__handshake_ack__free_unpacked
                     (Tetris__HandshakeACK *message,
                      ProtobufCAllocator *allocator);
/* Tetris__Report__Users methods */
void   tetris__report__users__init
                     (Tetris__Report__Users         *message);
/* Tetris__Report__JoystickInfo methods */
void   tetris__report__joystick_info__init
                     (Tetris__Report__JoystickInfo         *message);
/* Tetris__Report__TactileInfo methods */
void   tetris__report__tactile_info__init
                     (Tetris__Report__TactileInfo         *message);
/* Tetris__Report__ScreenInfo methods */
void   tetris__report__screen_info__init
                     (Tetris__Report__ScreenInfo         *message);
/* Tetris__Report methods */
void   tetris__report__init
                     (Tetris__Report         *message);
size_t tetris__report__get_packed_size
                     (const Tetris__Report   *message);
size_t tetris__report__pack
                     (const Tetris__Report   *message,
                      u8             *out);
size_t tetris__report__pack_to_buffer
                     (const Tetris__Report   *message,
                      ProtobufCBuffer     *buffer);
Tetris__Report *
       tetris__report__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const u8       *data);
void   tetris__report__free_unpacked
                     (Tetris__Report *message,
                      ProtobufCAllocator *allocator);
/* Tetris__Error methods */
void   tetris__error__init
                     (Tetris__Error         *message);
size_t tetris__error__get_packed_size
                     (const Tetris__Error   *message);
size_t tetris__error__pack
                     (const Tetris__Error   *message,
                      u8             *out);
size_t tetris__error__pack_to_buffer
                     (const Tetris__Error   *message,
                      ProtobufCBuffer     *buffer);
Tetris__Error *
       tetris__error__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const u8       *data);
void   tetris__error__free_unpacked
                     (Tetris__Error *message,
                      ProtobufCAllocator *allocator);
/* Tetris__ProgressUpdate__JoystickUpdate methods */
void   tetris__progress_update__joystick_update__init
                     (Tetris__ProgressUpdate__JoystickUpdate         *message);
/* Tetris__ProgressUpdate__TactileUpdate methods */
void   tetris__progress_update__tactile_update__init
                     (Tetris__ProgressUpdate__TactileUpdate         *message);
/* Tetris__ProgressUpdate__ScreenUpdate__Click methods */
void   tetris__progress_update__screen_update__click__init
                     (Tetris__ProgressUpdate__ScreenUpdate__Click         *message);
/* Tetris__ProgressUpdate__ScreenUpdate methods */
void   tetris__progress_update__screen_update__init
                     (Tetris__ProgressUpdate__ScreenUpdate         *message);
/* Tetris__ProgressUpdate methods */
void   tetris__progress_update__init
                     (Tetris__ProgressUpdate         *message);
size_t tetris__progress_update__get_packed_size
                     (const Tetris__ProgressUpdate   *message);
size_t tetris__progress_update__pack
                     (const Tetris__ProgressUpdate   *message,
                      u8             *out);
size_t tetris__progress_update__pack_to_buffer
                     (const Tetris__ProgressUpdate   *message,
                      ProtobufCBuffer     *buffer);
Tetris__ProgressUpdate *
       tetris__progress_update__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const u8       *data);
void   tetris__progress_update__free_unpacked
                     (Tetris__ProgressUpdate *message,
                      ProtobufCAllocator *allocator);
/* Tetris__Histogram::u321D methods */
void   tetris__histogram_uint1_d__init
                     (Tetris__Histogram::u321D         *message);
size_t tetris__histogram_uint1_d__get_packed_size
                     (const Tetris__Histogram::u321D   *message);
size_t tetris__histogram_uint1_d__pack
                     (const Tetris__Histogram::u321D   *message,
                      u8             *out);
size_t tetris__histogram_uint1_d__pack_to_buffer
                     (const Tetris__Histogram::u321D   *message,
                      ProtobufCBuffer     *buffer);
Tetris__Histogram::u321D *
       tetris__histogram_uint1_d__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const u8       *data);
void   tetris__histogram_uint1_d__free_unpacked
                     (Tetris__Histogram::u321D *message,
                      ProtobufCAllocator *allocator);
/* Tetris__Coordinate methods */
void   tetris__coordinate__init
                     (Tetris__Coordinate         *message);
size_t tetris__coordinate__get_packed_size
                     (const Tetris__Coordinate   *message);
size_t tetris__coordinate__pack
                     (const Tetris__Coordinate   *message,
                      u8             *out);
size_t tetris__coordinate__pack_to_buffer
                     (const Tetris__Coordinate   *message,
                      ProtobufCBuffer     *buffer);
Tetris__Coordinate *
       tetris__coordinate__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const u8       *data);
void   tetris__coordinate__free_unpacked
                     (Tetris__Coordinate *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Tetris__Handshake_Closure)
                 (const Tetris__Handshake *message,
                  void *closure_data);
typedef void (*Tetris__HandshakeACK_Closure)
                 (const Tetris__HandshakeACK *message,
                  void *closure_data);
typedef void (*Tetris__Report__Users_Closure)
                 (const Tetris__Report__Users *message,
                  void *closure_data);
typedef void (*Tetris__Report__JoystickInfo_Closure)
                 (const Tetris__Report__JoystickInfo *message,
                  void *closure_data);
typedef void (*Tetris__Report__TactileInfo_Closure)
                 (const Tetris__Report__TactileInfo *message,
                  void *closure_data);
typedef void (*Tetris__Report__ScreenInfo_Closure)
                 (const Tetris__Report__ScreenInfo *message,
                  void *closure_data);
typedef void (*Tetris__Report_Closure)
                 (const Tetris__Report *message,
                  void *closure_data);
typedef void (*Tetris__Error_Closure)
                 (const Tetris__Error *message,
                  void *closure_data);
typedef void (*Tetris__ProgressUpdate__JoystickUpdate_Closure)
                 (const Tetris__ProgressUpdate__JoystickUpdate *message,
                  void *closure_data);
typedef void (*Tetris__ProgressUpdate__TactileUpdate_Closure)
                 (const Tetris__ProgressUpdate__TactileUpdate *message,
                  void *closure_data);
typedef void (*Tetris__ProgressUpdate__ScreenUpdate__Click_Closure)
                 (const Tetris__ProgressUpdate__ScreenUpdate__Click *message,
                  void *closure_data);
typedef void (*Tetris__ProgressUpdate__ScreenUpdate_Closure)
                 (const Tetris__ProgressUpdate__ScreenUpdate *message,
                  void *closure_data);
typedef void (*Tetris__ProgressUpdate_Closure)
                 (const Tetris__ProgressUpdate *message,
                  void *closure_data);
typedef void (*Tetris__Histogram::u321D_Closure)
                 (const Tetris__Histogram::u321D *message,
                  void *closure_data);
typedef void (*Tetris__Coordinate_Closure)
                 (const Tetris__Coordinate *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor tetris__handshake__descriptor;
extern const ProtobufCMessageDescriptor tetris__handshake_ack__descriptor;
extern const ProtobufCMessageDescriptor tetris__report__descriptor;
extern const ProtobufCMessageDescriptor tetris__report__users__descriptor;
extern const ProtobufCMessageDescriptor tetris__report__joystick_info__descriptor;
extern const ProtobufCMessageDescriptor tetris__report__tactile_info__descriptor;
extern const ProtobufCMessageDescriptor tetris__report__screen_info__descriptor;
extern const ProtobufCMessageDescriptor tetris__error__descriptor;
extern const ProtobufCMessageDescriptor tetris__progress_update__descriptor;
extern const ProtobufCMessageDescriptor tetris__progress_update__joystick_update__descriptor;
extern const ProtobufCMessageDescriptor tetris__progress_update__tactile_update__descriptor;
extern const ProtobufCMessageDescriptor tetris__progress_update__screen_update__descriptor;
extern const ProtobufCMessageDescriptor tetris__progress_update__screen_update__click__descriptor;
extern const ProtobufCMessageDescriptor tetris__histogram_uint1_d__descriptor;
extern const ProtobufCMessageDescriptor tetris__coordinate__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_tetris_2eproto__INCLUDED */
